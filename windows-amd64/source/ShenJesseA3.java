/* autogenerated by Processing revision 1286 on 2022-12-08 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.Iterator;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class ShenJesseA3 extends PApplet {

final int TEXT_SIZE = 32;

final int FRAME_RATE = 60;
final int NUM_BIRD_FRAMES = 4;
final float ANIMATION_FR = 10;
final float ANIMATION_PER_FRAME = ANIMATION_FR/FRAME_RATE;

final float OBJECTS_Z = -0.9f;

final int NUM_ENEMY_PROPERTIES = 2;

World newWorld;
Player newPlayer;
ArrayList<Enemy> newEnemies;
ArrayList<Float> birdFrame;
ArrayList<Flock> flock;
ArrayList<boolean[]> enemiesProperties;
PImage playerImg;
PImage poopImg;
PImage ballImg;
PImage featherImg;
PImage snowImg;
PImage tile1;
PImage tile2;
PImage over;
PImage side;
PImage start;
PImage[] birdMove = new PImage[NUM_BIRD_FRAMES];
PImage[] birdPoopMove = new PImage[NUM_BIRD_FRAMES];

int count = 0;
int timer = 0;
int score;
int life;
int bonus;
boolean levelUp;
boolean newLife;
//boolean increaseDifficulty;
boolean startGame;
boolean gameOver;

int maxPlayerParticles; //change on difficulty
int maxEnemies; //change on difficulty
int maxEnemyParticles; //change on difficulty

int black;
int white;
int yellow;
int red;

 public void setup() {
  /* size commented out by preprocessor */; // change the dimensions if desired
  colorMode(RGB, 1.0f);
  textureMode(NORMAL); // use normalized 0..1 texture coords
  textureWrap(REPEAT);
  setupPOGL();
  setupProjections();
  resetMatrix(); // do this here and not in draw() so that you don't reset the camera

  black = color(0);
  white = color(1);
  yellow = color(240/255f, 225/255f, 110/255f);
  red = color(245/255f, 60/255f, 15/255f);

  //Load texture and animation files
  side = loadImage("column.jpg");
  over = loadImage("gameOver.png");
  //playerImg = loadImage("player0.png");
  //ballImg = loadImage("ball0.png");
  poopImg = loadImage("poop.png");
  featherImg = loadImage("feather.png");
  snowImg = loadImage("snow1.png");
  tile1 = loadImage("snow0.png");
  tile2 = loadImage("snow1.png");
  start = loadImage("start.png");

  //initiate game settings
  resetGame();
}

 public void resetGame() {
  //inital settings
  score = 0;
  maxPlayerParticles = 5; //change on difficulty
  maxEnemies = 1; //change on difficulty
  maxEnemyParticles = 3; //change on difficulty
  life = 2;
  bonus = 50;
  updateOrthoBounds();
  //initate objects
  initiateObjects();
}

 public void initiateObjects() {
  newWorld = new World();
  newPlayer = new Player();
  birdFrame = new ArrayList<>();
  newEnemies = new ArrayList<Enemy>();
  enemiesProperties = new ArrayList<>();
  flock = new ArrayList<>();

  initiateEnemies();
  setupBird();
}

 public void initiateEnemies() {
  for (int i = 0; i< maxEnemies; i++) {
    enemiesProperties.add(new boolean[NUM_ENEMY_PROPERTIES]);
    newEnemies.add(new Enemy(i));
    birdFrame.add(0.0f);
  }
  enemiesProperties.get(0)[SHOW] = true;
}


 public void setupBird() {
  for (int i = 0; i<NUM_BIRD_FRAMES; i++) {
    birdMove[i] = loadImage("bird" + i + ".png");
    birdPoopMove[i] = loadImage("birdPoop" + i + ".png");
  }
}



 public void draw() {
  clear();
  background(1);

  if (orthoMode) {
    resetMatrix();

    setProjection(projectOrtho);
  } else {
    resetMatrix();
    setProjection(projectPerspective);
    camera(0, -1, 0.5f,
      0, -0.7f, 0,
      0, 0, 1);
  }


  pushMatrix();
  movingWorld();
  popMatrix();
  if (!startGame) {
    startGame();
  }

  if (startGame) {
    pushMatrix();
    textSize(TEXT_SIZE);
    translate(0, 0, OBJECTS_Z);
    scale(0.003f, -0.003f, 1);
    fill(black);
    text("Score: " + score +"   Life: " + life, -125, -300);
    popMatrix();

    if (!gameOver) {
      pushMatrix();
      movingPlayer();
      popMatrix();
    } else {
      pushMatrix();
      endGame();
      popMatrix();
    }

    pushMatrix();
    movingEnemy();
    pushMatrix();
    translate(0, 0, OBJECTS_Z);
    checkFlock();
    popMatrix();
    popMatrix();
    if (timer == 750) {
      enemyLevelUp();
      timer = 0;
    }

    timer++;
  }
}

 public void movingWorld() {
  count ++;
  if (count > (TOTAL_GRID_LENGTH+20)*2) {
    newWorld.newGrid();
    //changed = true;
    count = 0;
  }
  translate(0, -(float)count/200);
  newWorld.draw();
}

 public void movingPlayer() {
  newPlayer.draw();
}

 public void movingEnemy() {
  for (int i = 0; i<maxEnemies; i++) {
    newEnemies.get(i).draw();
  }
}

 public void checkFlock() {
  for (int i =0; i< flock.size(); i++) {
    Flock curr = flock.get(i);
    curr.run();
    curr.delete();
    if (curr.numNodes<1) {
      if (curr.isPlayer) {
        if (life == 0) {
          gameOver=true;
        } else {
          newPlayer = new Player();
          isPlayerDead = false;
          newLife = true;
        }
      }
      flock.remove(curr);
    }
  }
}

 public void startGame() {
  translate(0, 0, OBJECTS_Z);
  scale(1, 1, -0.1f);
  noStroke();
  drawTextureSquare3D(start, OBJECTS_Z);
}


 public void endGame() {
  translate(0, 0, OBJECTS_Z);
  scale(1, 1, -0.1f);
  noStroke();
  drawTextureSquare3D(over, OBJECTS_Z);
}


 public boolean checkCollision(float x2, float x1, float y2, float y1, float r1, float r2) {
  float circleDist = (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1);
  float radiiSum = (r1+r2)*(r1*r2);
  if (circleDist <= radiiSum) {
    return true;
  } else {
    return false;
  }
}

 public void hits(boolean isPlayer, float x, float y) {
  int numNodes = 0;
  if (isPlayer) {
    numNodes = 1000;
  } else {
    numNodes = 100;
  }
  flock.add(new Flock(isPlayer, numNodes));
  Flock curr = flock.get(flock.size()-1);
  for (int i = 0; i < numNodes; i++) {
    curr.addNode(new Node(isPlayer, x, y));
  }
}
//final int FLASH_INTERVAL = 5;
//final boolean[] FLASH = {false, true, false, true, false};  //enemy will engage flash from time to time as added difficulty

final int SHOW = 0;
final int CONSTANT_SPEED = 1;

final int NUM_KEYFRAMES = 3; // 3 points a,b,c ==> while a->b, randomize c, then b->c randomize a, c->b randomize b, repeat
final int NUM_DATA = 4; //X,Y,SCALE,ANGLE

final int X = 0;
final int Y = 1;
final int SCALE = 1;
final int ANGLE = 3;


final int NUM_STEPS = 150; //adjusts enemy moving speed

boolean doFlip = false;

float maxEnemyScale = 1.5f;
float minEnemyScale = 1.25f; //changes base on difficulty

int stepUp = 25;

class Enemy {
  int numSteps;
  float t;
  int counter;
  int startFrame = 0;
  int endFrame = 1;
  int freeFrame = 2;
  PVector[] vertices = new PVector[NUM_KEYFRAMES];
  int enemyIndex;
  float enemyXPos, enemyYPos;
  float maxTopXPos, maxTopYPos;
  float[][] keyFrames = new float[NUM_KEYFRAMES][NUM_DATA];

  float scale;

  boolean doPooping = false;

  int birdFrameIndex;

  Particle[] enemyParticles;
  int[] particleStepCounter;

  boolean[] showEnemyParticles = new boolean[maxEnemyParticles];

  Enemy(int enemyIndex) {
    this.enemyIndex = enemyIndex;

    initiateEnemy();
    initiateParticles();
  }

   public void initiateEnemy() {
    scale = random(minEnemyScale, maxEnemyScale);

    vertices[0] = randomVector(-topXBound, topXBound, -1, topYBound);
    vertices[1] = randomVector(-topXBound, topXBound, -1, topYBound);
    vertices[2] = randomVector(-topXBound, topXBound, -1, topYBound);

    if (random(2) > 1 ) {
      enemiesProperties.get(enemyIndex)[CONSTANT_SPEED] = true;
    }
    numSteps=numStepsForConstantSpeed(vertices[startFrame], vertices[endFrame], stepUp);
  }
  
   public void initiateParticles() {
    enemyParticles = new Particle[maxEnemyParticles];
    particleStepCounter = new int[maxEnemyParticles];
    for (int i = 0; i< maxEnemyParticles; i++) {
      enemyParticles[i] = new Particle(i, 0, 0, showEnemyParticles, enemyIndex, false);
    }
  }

   public PVector randomVector(float minX, float maxX, float minY, float maxY) {
    return new PVector(random(minX, maxX), random(minY, maxY));
  };

   public void draw() {
    pushMatrix();
    scale(GLOBAL_SCALE, GLOBAL_SCALE, 1);
    
    if (enemiesProperties.get(enemyIndex)[SHOW]) {
      pushMatrix();
      updateCounter();
      t = parameterFromCounter(counter);

      enemyXPos = lerp(vertices[startFrame].x, vertices[endFrame].x, t);
      enemyYPos = lerp(vertices[startFrame].y, vertices[endFrame].y, t);

      if (vertices[endFrame].x < vertices[startFrame].x) {
        doFlip = true;
      } else {
        doFlip = false;
      }

      if (checkCollision(vertices[endFrame].x, enemyXPos, vertices[endFrame].y, enemyYPos, 1, 1)) {
        doPooping= true;
      } else {
        doPooping = false;
      }

      drawMovingEnemy();
      updateBirdAnimation();
      popMatrix();
    }
    pushMatrix();
    //drawParticles();
    translate(0, 0, OBJECTS_Z);
    for (int i = 0; i<maxEnemyParticles; i++) {
      if (showEnemyParticles[i])
        enemyParticles[i].draw();
    }
    popMatrix();
    popMatrix();
  }


   public void drawMovingEnemy() {
    pushMatrix();

    translate(enemyXPos, enemyYPos, OBJECTS_Z);



    drawSingleEnemy();
    popMatrix();
  }

   public void drawSingleEnemy() {
    if (doTextures) {
      PImage img;
      scale(scale);

      if (doPooping) {
        scale(GLOBAL_SCALE+1, GLOBAL_SCALE+1);
        img = birdPoopMove[birdFrameIndex];
      } else {
        img = birdMove[birdFrameIndex];
      }

      //flip x-axis for left-right travel directions
      if (doFlip) {
        drawSingleTextureSquareFlip(img);
      } else {
        drawSingleTextureSquare(img);
      }
    } else {
      fill(red);
      drawSingleSquare();
    }
  }

   public void drawParticles() {
    for (int i = 0; i < maxEnemyParticles; i++) {
      if (showEnemyParticles[i]) {
        enemyParticles[i].draw();
      }
    }
  }

  //counter for moving enemy
   public void updateCounter() {
    counter++;
    if (nextKeyframe(counter)) {

      freeFrame = startFrame;
      startFrame = (startFrame+1) % NUM_KEYFRAMES; // num_keyframes = 3
      endFrame = (endFrame+1) % NUM_KEYFRAMES;
      vertices[freeFrame] = randomVector(-10, 10, -3, 9);
      counter = 0;
      numSteps=numStepsForConstantSpeed(vertices[startFrame], vertices[endFrame], stepUp);
      enemyFire();
    }
  }

   public boolean nextKeyframe(int c) {
    boolean goToNext;
    if (enemiesProperties.get(enemyIndex)[CONSTANT_SPEED]) {
      goToNext = c >= numSteps;
    } else {
      goToNext = c >= NUM_STEPS;
    }
    return goToNext;
  }


   public float parameterFromCounter(int c) {
    float t;
    if (enemiesProperties.get(enemyIndex)[CONSTANT_SPEED]) {
      t = (float)c/numSteps;
    } else {
      t = (float)c/NUM_STEPS;
    }
    return t;
  }

   public void enemyFire() {
    for (int i = 0; i<maxEnemyParticles; i++) {
      if (!showEnemyParticles[i]) {
        updateEnemyParticle(i);
        break;
      }
    }
  }

   public void updateEnemyParticle(int i) {
    enemyParticles[i].updateParticle(i, enemyXPos, enemyYPos);
  }

   public PVector getEnemyPosition() {
    return new PVector(enemyXPos, enemyYPos);
  }

   public void updateBirdAnimation() {
    birdFrame.set(enemyIndex, (birdFrame.get(enemyIndex) + ANIMATION_PER_FRAME) % NUM_BIRD_FRAMES);
    float frame = birdFrame.get(enemyIndex);
    birdFrameIndex = (int)frame;
  }
}



final float GLOBAL_SCALE = 0.1f;

class Flock {
  ArrayList<Node> nodes; // An ArrayList for all the nodes
  int numNodes;
  boolean isPlayer;

  Flock(boolean isPlayer, int numNodes) {
    nodes = new ArrayList<Node>(); // Initialize the ArrayList
    this.numNodes = numNodes;
    this.isPlayer = isPlayer;
  }

   public void run() {
    for (Node n : nodes) {
      n.run();  // Passing the entire list of boids to each boid individually
      pushMatrix();
      scale(GLOBAL_SCALE, GLOBAL_SCALE, 1);
      n.render();
      popMatrix();
    }
  }

   public void addNode(Node n) {
    nodes.add(n);
  }

   public void delete() {
    Iterator<Node> itr = nodes.iterator();
    while (itr.hasNext()) {
      Node n = itr.next();
      if (!n.alive) {
        itr.remove();
        numNodes--;
      }
    }
  }
}


class Node {
  PImage img;

  int maxLifespan = 60; // frames
  int lifespan;  // total lifespan in frames
  int t;  // number of frames lived so far

  float maxspeed;
  float r;

  boolean alive;
  boolean isPlayer;

  PVector position;
  PVector velocity;

  Node(boolean isPlayer, float x, float y) {
    this.isPlayer = isPlayer;
    if (isPlayer) {
      maxLifespan = 180;
    }
    img = featherImg;
    velocity = PVector.random3D();
    velocity.normalize();
    position = new PVector(x, y, 0);
    r = 1.0f;
    maxspeed = 0.075f;
    alive = true;
    lifespan = (int)random(maxLifespan);
    t = 0;
  }

   public void run() {
    update();
    lifecycle();
  }

   public void update() {
    velocity.limit(maxspeed);
    position.add(velocity);
  }

   public void lifecycle() {
    t++;
    if (t > lifespan) {
      alive = false;
    }
  }

   public void render() {
    // Draw a triangle rotated in the direction of velocity
    float theta = velocity.heading() + radians(-90);

    pushMatrix();
    translate(position.x, position.y, position.z*0.1f);
    rotate(theta);

    if (isPlayer) {
      scale(0.15f, 0.15f, 1);
      fill(random(1), random(1), random(1));
      drawSingleSquare();
    } else {
      scale(0.25f, 0.55f, 1);
      drawSingleTextureSquare(img);
    }
    popMatrix();
  }
}

 public void enemyLevelUp() {
  if (maxEnemies < 10) {
    enemiesProperties.add(maxEnemies, new boolean[NUM_ENEMY_PROPERTIES]);
    newEnemies.add(maxEnemies, new Enemy(maxEnemies));
    birdFrame.add(0.0f);
    enemiesProperties.get(maxEnemies)[SHOW]=true;
    maxEnemies++;
    levelUp = false;
  }
  if (score>0 && score % 5 ==0 && minEnemyScale > 0.75f && maxEnemyScale >= minEnemyScale) {
    minEnemyScale -= 0.01f;
    maxEnemyScale -= 0.01f;
    stepUp-=1;
  }
  System.out.println("Difficulty Increased!");
}

 public void playerLevelUp() {
  life++;
  System.out.println("Bonus Life!");
}

final char KEY_VIEW = 'r'; // switch between orthographic and perspective views

// player character
final char KEY_LEFT = 'a';
final char KEY_RIGHT = 'd';
final char KEY_UP = 'w';
final char KEY_DOWN = 's';
final char KEY_SHOOT = ' ';

// useful for debugging to turn textures or collisions on/off
final char KEY_TEXTURE = 't';
final char KEY_COLLISION = 'c';

final char KEY_BONUS = 'b';
final char KEY_NO_CONSTANT_SPEED = '-';
final char KEY_CONSTANT_SPEED = '=';
final char KEY_GODSHOT = '*';
final char KEY_RESET = 'p';

final char KEY_PLAYER1 = '1';
final char KEY_PLAYER2 = '2';
final char KEY_PLAYER3 = '3';

boolean doTextures = true;
boolean doCollision = true;
boolean doGodShot = false;

enum ViewMode {
  ORTHO,
    PERSPEC,
}

boolean orthoMode = true;
boolean perspecMode = false;

 public void keyPressed()
{
  if (key == KEY_VIEW) {
    orthoMode = !orthoMode;
    perspecMode = !perspecMode;
    if (orthoMode) {
      System.out.println("Current viewing mode: Ortho");
    } else {
      System.out.println("Current viewing mode: Perspective" );
    }
  }

  if (key == KEY_TEXTURE) {
    doTextures = !doTextures;
    System.out.println("doTextures: "+ doTextures);
  }

  if (key == KEY_LEFT) {
    bankLeft = true;
    moveLeft = true;
    newLife = false;
  }
  if (key == KEY_RIGHT) {
    bankRight = true;
    moveRight = true;
    newLife = false;
  }
  if (key == KEY_UP) {
    bankUp = true;
    moveUp = true;
    newLife = false;
  }
  if (key == KEY_DOWN) {
    bankDown = true;
    moveDown = true;
    newLife = false;
  }

  if (key == KEY_COLLISION) {
    doCollision = !doCollision;
    System.out.println("doCollision: "+ doCollision);
  }

  if (key == KEY_GODSHOT) {
    doGodShot = !doGodShot;
    System.out.println("doGodShot: "+ doGodShot);
  }

  if (key == KEY_RESET && gameOver) {
    resetGame();
    startGame = false;
    gameOver =!gameOver;
    System.out.println("Game restarted");
  }

  if (key == KEY_SHOOT && !isPlayerDead) {
    newLife = false;
    for (int i = 0; i < maxPlayerParticles; i++) {
      if (!newPlayer.showPlayerParticles[i]) {
        newPlayer.updatePlayerParticle(i);
        break;
      }
    }
  }

  if (key == KEY_CONSTANT_SPEED) {
    for (int i = 0; i< maxEnemies; i++) {
      enemiesProperties.get(i)[CONSTANT_SPEED]= true;
    }
  }
  if (key == KEY_NO_CONSTANT_SPEED) {
    for (int i = 0; i< maxEnemies; i++) {
      enemiesProperties.get(i)[CONSTANT_SPEED]= false;
    }
  }
  if (key == KEY_PLAYER1 && !startGame) {
    playerImg = loadImage("player1.png");
    ballImg = loadImage("ball1.png");
    startGame = true;
  }
  if (key == KEY_PLAYER2 && !startGame) {
    playerImg = loadImage("player2.png");
    ballImg = loadImage("ball2.png");
    startGame = true;
  }
  if (key == KEY_PLAYER3 && !startGame) {
    playerImg = loadImage("player3.png");
    ballImg = loadImage("ball3.png");
    startGame = true;
  }
}

 public void keyReleased() {
  if (key == KEY_LEFT) {
    bankLeft = false;
    moveLeft = false;
  }
  if (key == KEY_RIGHT) {
    bankRight = false;
    moveRight = false;
  }
  if (key == KEY_UP) {
    bankUp = false;
    moveUp = false;
  }
  if (key == KEY_DOWN) {
    bankDown = false;
    moveDown = false;
  }
}

//particles

boolean shoot = false;

float particleSpeed = 0.2f;

class Particle {

  float scale = 0.45f;
  float particleXPos, particleYPos;
  int posIndex;
  boolean[] showParticles;  //do we need this?
  float originX, originY;
  boolean isPlayer;
  float t;
  int numStep=0;
  PVector playerPos;
  float slope =1;
  float initX;
  float initY;
  int count=20;
  float endX;
  float endY;
  float bound = -11;
  int enemyIndex;
  float rEnemy = 1.5f;
  float rPlayer = 1;
  float rParticle = 0.75f;
  float rPoop = 1;

  Particle(int posIndex, float x, float y, boolean[] showParticles, int enemyIndex, boolean isPlayer) {
    this.posIndex = posIndex;
    particleXPos = x;
    particleYPos = y;
    this.showParticles = showParticles;
    this.isPlayer = isPlayer;
    playerPos = new PVector();
    this.enemyIndex = enemyIndex;
  }

   public void draw() {

    pushMatrix();

    if (doCollision) {
      if (isPlayer) {
        checkPlayerShot();
      } else {
        checkEnemyShot();
      }
    }

    movingParticle();

    popMatrix();
  }
   public void checkPlayerShot() {

    for (int i = 0; i< maxEnemies; i++) {
      Enemy currEnemy = newEnemies.get(i);
      if (enemiesProperties.get(i)[SHOW]) {
        rEnemy = currEnemy.scale*1.55f;
        if (checkCollision(currEnemy.enemyXPos, particleXPos, currEnemy.enemyYPos, particleYPos, rEnemy, rParticle)) {
          enemiesProperties.get(i)[SHOW] = false;
          if (!doGodShot) {

            showParticles[posIndex]= false;
          }

          hits(false, currEnemy.enemyXPos, currEnemy.enemyYPos);

          checkEnemyReset(i);
          updateScore();
          break;
        }
      }
    }
  }

   public void checkEnemyShot() {
    PVector playerPos = newPlayer.getPlayerPosition();
    float playerX = playerPos.x;
    float playerY = playerPos.y;
    if (!isPlayerDead && checkCollision(particleXPos, playerX, particleYPos, playerY, rPoop, rPlayer)) {
      //TODO player explode
      showParticles[posIndex]=false;
      isPlayerDead = true;
      hits(true, playerX, playerY);
      life--;
    }
  }

   public void updateScore() {
    score++;
    if (score % (((score/10)+1)*10) == 0) {
      enemyLevelUp();
    }

    if (score % bonus == 0) {
      playerLevelUp();
      bonus = 100;
    }
  }

   public void movingParticle() {


    if (isPlayer) {
      //player particle straight y
      particleYPos += particleSpeed;
      translate(particleXPos, particleYPos+1.2f);
      scale(scale);

      drawSingleParticle();
      if (particleYPos > topYBound) {
        showParticles[posIndex] = false;
      }
    } else {

      count++;

      if (numStep == 0) {
        playerPos = newPlayer.getPlayerPosition();
        PVector enemyPos = new PVector(particleXPos, particleYPos);
        slope = (playerPos.y - particleYPos)/(playerPos.x-particleXPos);
        numStep = numStepsForConstantSpeed(enemyPos, playerPos, 1000);

        initX = particleXPos;
        initY = particleYPos;
        if (slope == 0) {
          slope =1;
        }
        
        if (playerPos.y > particleYPos) {
          endY = topYBound*2;
          //endY = 20;
        } else {
          //endY = -20;
          endY = -topYBound*2;
        }

        if (Math.abs(playerPos.y -initY) < Math.abs(playerPos.x-initX)) {
          if (playerPos.x > particleXPos) {
            //endX = 20;
            endX = topXBound*2;
          } else {
            //endX = -20;
            endX = -topXBound*2;
          }
        } else {
          endX =max(min((endY-initY)/slope + initX, 20), -20);
        }
        if (endX <= -20 || endX >= 12) {
          endY = (endX-initX)*slope + initY ;
        }
      }

      t= (float)count/numStep;
      particleXPos = lerp(particleXPos, endX, t);
      particleYPos = lerp(particleYPos, endY, t);

      translate(particleXPos, particleYPos);
      scale(scale);

      drawSingleParticle();

      if (particleYPos < -11 || particleYPos > 11 || particleXPos > 11 || particleXPos < -11) {

        numStep = 0;
        count=20;

        showParticles[posIndex]=false;

        if (!isPlayer) {
          checkEnemyReset(enemyIndex);
        }
      }

    }
  }

   public void checkEnemyReset(int index) {
    if (!enemiesProperties.get(index)[SHOW]) {
      Enemy currEnemy = newEnemies.get(index);
      boolean reset = true;
      for (int i = 0; i< maxEnemyParticles; i++) {
        if (currEnemy.showEnemyParticles[i]) {
          reset = false;
          break;
        }
      }
      if (reset) {
        newEnemies.set(index, new Enemy(index));
        enemiesProperties.get(index)[SHOW] = true;
      }
    }
  }

   public void drawSingleParticle() {
    pushMatrix();
    if (doTextures) {
      if (!isPlayer) {
        scale(0.9f, 1.5f,GLOBAL_SCALE);
        drawSingleTextureSquare(poopImg);
      } else {
        drawSingleTextureSquare(ballImg);
      }
    } else {
      fill(black);
      circle(0, 0, 1);
    }
    popMatrix();
  }

   public void updateParticle(int i, float originX, float originY) {
    showParticles[i] = true;
    setParticlePos(originX, originY);
  }

   public void setParticlePos(float x, float y) {
    particleXPos = x;
    particleYPos = y;
  }
}


final float Y_BANK = PI/6;
final float X_BANK = PI/6;
final float PLAYER_SCALE = 1.4f;
final float MOVE_SPEED = 0.2f;
final float RETURN_SPEED = 0.05f;
final int Y_OFFSET = -8;

boolean moveLeft = false;
boolean moveRight = false;
boolean moveUp = false;
boolean moveDown = false;
boolean faceRight = true;

boolean bankLeft = false;
boolean bankRight = false;
boolean bankUp = false;
boolean bankDown = false;

boolean isPlayerDead;

float topXBound;
float botXBound;
float topYBound;
float botYBound;
float orthoOffset;

float perspectiveBoundSlope=1;

int currentParticle = 0;

class Player {
  boolean isPlayer;
  float rPlayer = 1;
  float playerXPos = 0;
  float playerYPos = Y_OFFSET;
  boolean[] showPlayerParticles = new boolean[maxPlayerParticles];
  Particle[] playerParticles;

  Player() {
    isPlayerDead = false;
    isPlayer = true;
    
    initiatePlayerParticles();
  }

   public void initiatePlayerParticles() {
    float initX = 0;
    float initY = 0;
    int notEnemy = -1;

    playerParticles = new Particle[maxPlayerParticles];
    for (int i = 0; i< maxPlayerParticles; i++) {
      playerParticles[i] = new Particle(i, initX, initY, showPlayerParticles, notEnemy, isPlayer);
    }
  }

   public void draw() {
    pushMatrix();
    translate(0, 0, OBJECTS_Z);
    scale(GLOBAL_SCALE);
    if (orthoMode) {
      updateOrthoBounds();
      orthoOffset = playerYPos;
    } else {
      updatePerspectiveBounds();
      perspectiveBoundSlope = (topYBound-botYBound)/(topXBound-botXBound);
    }

    checkNewLife();

    drawPlayerParticles();
    movePlayer();
    translatePlayer();
    drawPlayer();
    noTint();
    popMatrix();

    if (doCollision) {
      checkEnemyCollision();
    }
  }

   public void drawPlayer() {
    pushMatrix();
    scale(PLAYER_SCALE, PLAYER_SCALE);
    if (!isPlayerDead) {
      if (doTextures) {
        if(faceRight){
        drawSingleTextureSquare(playerImg);
      }else{
        drawSingleTextureSquareFlip(playerImg);
      }
        
      } else {
        fill(red);
        drawSingleSquare();
      }
    }
    popMatrix();
  }

   public void drawPlayerParticles() {
    for (int i = 0; i < maxPlayerParticles; i++) {
      if (showPlayerParticles[i]) {
        playerParticles[i].draw();
      }
    }
  }

   public void checkNewLife() {
    if (newLife) {
      doCollision = false;
      tint(1, 0.5f);
    } else {
      doCollision = true;
    }
  }

   public void checkEnemyCollision() {
    PVector currEnemyPos;
    float enemyScale;
    Enemy currEnemy;
    float rEnemy;

    for (int i = 0; i < maxEnemies; i++) {
      currEnemy = newEnemies.get(i);
      currEnemyPos = currEnemy.getEnemyPosition();
      enemyScale = currEnemy.scale;
      rEnemy = enemyScale*1.3f;
      if (!isPlayerDead && checkCollision(currEnemyPos.x, playerXPos, currEnemyPos.y, playerYPos, rEnemy, rPlayer)) {
        enemiesProperties.get(i)[SHOW] = false;
        isPlayerDead = true;
        hits(false, currEnemyPos.x, currEnemyPos.y);
        hits(true, playerXPos, playerYPos);
        life--;
      }
    }
  }

   public void updatePlayerParticle(int i) {
    playerParticles[i].updateParticle(i, playerXPos, playerYPos);
  }

   public PVector getPlayerPosition() {
    return new PVector(playerXPos, playerYPos);
  }

   public void movePlayer() {
    if (moveLeft) {
      faceRight = false;
      movePlayerLeft();
    }
    if (moveRight) {
      faceRight = true;
      movePlayerRight();
    }
    if (moveUp) {
      movePlayerUp();
    }
    if (moveDown) {
      movePlayerDown();
    }
    if (!moveLeft && !moveRight && !moveUp && !moveDown) {
      returnPlayer();
    }
    translate(playerXPos, playerYPos);
  }

   public void movePlayerLeft() {
    playerXPos = constrain(playerXPos-MOVE_SPEED, -(botXBound+(playerYPos-orthoOffset)/perspectiveBoundSlope), (botXBound+(playerYPos-orthoOffset)/perspectiveBoundSlope));
  };

   public void movePlayerRight() {
    playerXPos = constrain(playerXPos+MOVE_SPEED, -(botXBound+(playerYPos-orthoOffset)/perspectiveBoundSlope), (botXBound+(playerYPos-orthoOffset)/perspectiveBoundSlope));
  };

   public void movePlayerUp() {
    playerYPos = constrain(playerYPos+MOVE_SPEED, botYBound, topYBound);
  };

   public void movePlayerDown() {
    playerYPos = constrain(playerYPos-MOVE_SPEED, botYBound, topYBound);
  };

   public void returnPlayer() {
    if (playerXPos > 0) {
      faceRight = false;
      playerXPos -= RETURN_SPEED;
    }
    if (playerXPos < 0) {
      faceRight = true;
      playerXPos += RETURN_SPEED;
    }
    if (playerYPos > Y_OFFSET) {
      playerYPos -= RETURN_SPEED;
    }
    if (playerYPos < Y_OFFSET) {
      playerYPos += RETURN_SPEED;
    }
  }

   public void translatePlayer() {
    if (bankLeft) {
      rotateY(-Y_BANK);
    }
    if (bankRight) {
      rotateY(Y_BANK);
    }
    if (bankUp) {
      rotateX(-X_BANK);
    }
    if (bankDown) {
      rotateX(X_BANK);
    }
  }
}

// Functions to compel Processing to let us edit the projection matrix
PGraphicsOpenGL pogl = null;

// called at the beginning of your code
 public void setupPOGL() {
  pogl = (PGraphicsOpenGL)g;
}

// for debugging
 public void printProjection() {
  pogl.projection.print();
}

// call immediately after using perspective() to create a view frustum
 public void fixFrustumYAxis() {
  PMatrix3D projection = getProjection();
  projection.preApply(new PMatrix3D(
    1, 0, 0, 0,
    0, -1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1
    ));
  setProjection(projection);
}

 public PMatrix3D getProjection() {
assert pogl != null:
  "no PGraphics OpenGL context";
  return pogl.projection.get();
}

 public void setProjection(PMatrix3D projectionMatrix) {
assert pogl != null:
  "no PGraphics OpenGL context";
  pogl.projection.set(projectionMatrix.get());
  pogl.updateProjmodelview();
}
class Tile {
  int primary;
  float zDistance = 0.7f;

  Tile(int primary) {
    this.primary = primary;
  }

   public void draw() {
    pushMatrix();
    drawTile();
    popMatrix();
  }

   public void drawTile() {
    strokeWeight(1);
    pushMatrix();
    stroke(this.primary);
    fill(this.primary);
    drawSingleSquare3D(zDistance);
    popMatrix();
  }
}

float MIN_COLOR = 0;
float MAX_COLOR = 256;

float MAX_GRID_LENGTH = 330;
float MIN_GRID_LENGTH = -110;

float TOTAL_GRID_LENGTH = (MAX_GRID_LENGTH-MIN_GRID_LENGTH);

float MAX_GRID_WIDTH = 200;
float MIN_GRID_WIDTH = -200;

int NUM_STACK = 2;

class TileGrid {
  int[] primary;
  Tile tile;
  PImage[] img;
  float[][] zH;

  TileGrid(int[] primary, PImage[] img, float[][] zH) {
    this.primary = primary;
    this.img = img;
    this.zH = zH;
  }

   public void draw() {
    drawGrid(this.primary);
  }

   public void newColor(int[] newC) {
    this.primary = newC;
  }
  
   public void drawGrid(int[] primary) {
    int count = 0;

    for (float i = MIN_GRID_WIDTH; i <= MAX_GRID_WIDTH; i+=20) {
      for (float j = MIN_GRID_LENGTH; j <= MAX_GRID_LENGTH; j+=20) {
        pushMatrix();
        translate(i/100, j/100, -2);
        scale(0.1f, 0.1f, 1);
        drawSingleTile(primary[count], img[count], zH[count]);
        count++;
        popMatrix();
      }
    }
  }
  
   public void drawSingleTile(int primary, PImage img, float[] zH) {
    if (doTextures) {
      drawTextureSquare3D(img, zH[NUM_STACK]);
      for (int i = NUM_STACK; i>=0; i--)
        if (zH[i]==0.5f) {
          drawTextureSideSquare3D(side, zH[i]);
          break;
        } else {
          drawTextureSideSquare3D(side, zH[i]);
        }
    } else {
      tile = new Tile(primary);
      tile.draw();
    }
  }
}

/*
Put your projection and camera operations here.
 Add more constants, variables and functions as needed.
 */

//ortho()
float left, right, top, bottom, near, far;

float fovY, aspect, zNear, zFar;

final float NEAR = 0.5f;
final float FAR = 200;

PMatrix3D projectOrtho, projectPerspective;

 public void setupProjections() {
  ortho(-1.1f, 1.1f, 1, -1, NEAR, FAR); // PLACEHOLDER - CHANGE THIS LINE TO USE YOUR CALCULATED PARAMETERS!
  projectOrtho = getProjection();
  fovY = PI/3;
  perspective(fovY, 1, NEAR, FAR); // PLACEHOLDER - CHANGE THIS LINE TO USE YOUR CALCULATED PARAMETERS!
  fixFrustumYAxis();
  projectPerspective = getProjection();
}

 public void updateOrthoBounds() {
  topXBound = 10;
  botXBound = 10;
  topYBound = 9;
  botYBound = -9;
}

 public void updatePerspectiveBounds() {
  topXBound = 14;
  botXBound = 8;
  topYBound = 11;
  botYBound = -8;
  orthoOffset = 0;
}

final float GRID_OFFSET = (TOTAL_GRID_LENGTH/20+1)/5;
int NUM_TILES = PApplet.parseInt((TOTAL_GRID_LENGTH/20+1) * ((MAX_GRID_WIDTH-MIN_GRID_WIDTH)/20+1));

class World{
  TileGrid currentGrid, nextGrid;

  World(){
   currentGrid = new TileGrid(randomColor(),randomImg(),randomZH());
   nextGrid = new TileGrid(randomColor(),randomImg(),randomZH());
  }

   public void draw(){   
    pushMatrix();
    drawTileGrid(currentGrid);
    translate(0,GRID_OFFSET);  
    drawTileGrid(nextGrid);
    popMatrix();
  }
 
   public void drawTileGrid(TileGrid grid){  
    grid.draw();
  }
  
   public void newGrid(){
    currentGrid = nextGrid;
    nextGrid = new TileGrid(randomColor(),randomImg(),randomZH());
  }
}
   public int[] randomColor(){
    int[] arr = new int[NUM_TILES];
    for (int i = 0; i < (NUM_TILES); i++){
      arr[i] = color(random(255)/255,random(255)/255,random(255)/255);
    }
    return arr;
  }
  
   public PImage[] randomImg(){
    PImage[] arr = new PImage[NUM_TILES];
    for(int i = 0; i<NUM_TILES; i++){
      if(random(4)>1){
      arr[i] = tile1;
      }else{
      arr[i] = tile2;
      }
    }
    return arr;
  }
   public float[][] randomZH(){
    float[][] arr = new float[NUM_TILES][3];
    for(int i = 0; i<NUM_TILES; i++){
      float rand = random(3);
      if(rand>2){
      arr[i][0] = 0.5f;
      arr[i][1] = 0.6f;
      arr[i][2] = 0.7f;
      }else if (rand > 1){
      arr[i][1] = 0.5f;
      arr[i][2] = 0.6f;
      }else{
      arr[i][2]= 0.5f;
      }
    }
    return arr;
  }
 public void drawSingleSquare() {
  beginShape(TRIANGLES);
  vertex(-1, -1);
  vertex(-1, 1);
  vertex(1, 1);
  vertex(1, 1);
  vertex(-1, -1);
  vertex(1, -1);
  endShape();
}

 public void drawSingleTextureSquare(PImage img) {
  beginShape(TRIANGLES);
  texture(img);
  vertex(-1, -1, 0, 1);
  vertex(1, -1, 1, 1);
  vertex(-1, 1, 0, 0);
  vertex(-1, 1, 0, 0);
  vertex(1, -1, 1, 1);
  vertex(1, 1, 1, 0);
  endShape();
}

 public void drawSingleTextureSquareFlip(PImage img) {
  beginShape(TRIANGLES);
  texture(img);
  vertex(-1, -1, 1, 1);
  vertex(1, -1, 0, 1);
  vertex(-1, 1, 1, 0);

  vertex(-1, 1, 1, 0);
  vertex(1, -1, 0, 1);
  vertex(1, 1, 0, 0);
  endShape();
}

 public void drawSingleSquare3D(float zDistance) {
  beginShape(TRIANGLES);
  vertex(-1, -1, zDistance);
  vertex(-1, 1, zDistance);
  vertex(1, 1, zDistance);
  vertex(1, 1, zDistance);
  vertex(-1, -1, zDistance);
  vertex(1, -1, zDistance);
  endShape();
}

 public void drawTextureSquare3D(PImage img, float zH) {
  noStroke();
  beginShape(TRIANGLES);
  texture(img);
  vertex(-1, -1, zH, 0, 1);
  vertex(1, -1, zH, 1, 1);
  vertex(-1, 1, zH, 0, 0);
  vertex(-1, 1, zH, 0, 0);
  vertex(1, -1, zH, 1, 1);
  vertex(1, 1, zH, 1, 0);
  endShape();
}

 public void drawTextureSideSquare3D(PImage img, float zH) {

  //front
  noStroke();
  beginShape(TRIANGLES);
  texture(img);
  vertex(-1, -1, zH, 0, 0);
  vertex(1, -1, zH, 1, 0);
  vertex(-1, -1, zH-0.1f, 0, 1);

  vertex(-1, -1, zH-0.1f, 0, 1);
  vertex(1, -1, zH, 1, 0);
  vertex(1, -1, zH-0.1f, 1, 1);
  endShape();

  //left
  noStroke();
  beginShape(TRIANGLES);
  texture(img);
  vertex(-1, 1, zH, 0, 0);
  vertex(-1, -1, zH, 1, 0);
  vertex(-1, 1, zH-0.1f, 0, 1);

  vertex(-1, 1, zH-0.1f, 0, 1);
  vertex(-1, -1, zH, 1, 0);
  vertex(-1, -1, zH-0.1f, 1, 1);
  endShape();

  //right
  noStroke();
  beginShape(TRIANGLES);
  texture(img);
  vertex(1, -1, zH, 0, 0);
  vertex(1, 1, zH, 1, 0);
  vertex(1, -1, zH-0.1f, 0, 1);

  vertex(1, -1, zH-0.1f, 0, 1);
  vertex(1, 1, zH, 1, 0);
  vertex(1, 1, zH-0.1f, 1, 1);
  endShape();
}

final float PIXELS_PER_SEC = 100;

 public int numStepsForConstantSpeed(PVector start, PVector end, float speed) {
  PVector displacement = end.copy();
  displacement.sub(start);    // subtract vector start with displacement
  float distance = displacement.mag();   //gets the magnitude of displacement
  return PApplet.parseInt(distance*speed*FRAME_RATE/PIXELS_PER_SEC);
}


  public void settings() { size(640, 640, P3D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "ShenJesseA3" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
